"""
Advanced Planner Engine (Plan-and-Solve).

Adheres to:
- Reasoning: Implements "Plan-and-Solve" prompting pattern for better zero-shot reasoning.
- Robustness: Validates generated graph structure.
"""
import logging
import orjson
from typing import Dict, Any, List

from ..core.inference_wrapper import get_inference_client, CompletionResult
from ..core.result import Result, Ok, Err
from .task_graph import TaskGraph

logger = logging.getLogger(__name__)

class Planner:
    """
    Advanced Breakdown Planner using Chain-of-Thought (CoT) and JSON-mode enforcement.
    """
    def __init__(self):
        self.graph = TaskGraph()

    async def create_plan(self, objective: str) -> Result[TaskGraph, Exception]:
        """
        Generates a robust plan via LLM.
        """
        # SOTA Prompt Engineering: Plan-and-Solve Pattern
        system_prompt = (
            "You are an expert AI Planner. "
            "Your goal is to decompose a complex user objective into a directed acyclic graph (DAG) of executable tasks.\n"
            "Rules:\n"
            "1. Tasks must be atomic and concrete.\n"
            "2. Define strict dependencies (ids).\n"
            "3. Output MUST be valid JSON matching the schema.\n\n"
            "JSON Schema:\n"
            "{\n"
            "  \"tasks\": [\n"
            "    {\"id\": \"1\", \"description\": \"Scan directory for files\", \"dependencies\": []},\n"
            "    {\"id\": \"2\", \"description\": \"Summarize content\", \"dependencies\": [\"1\"]}\n"
            "  ]\n"
            "}"
        )
        
        user_prompt = f"Objective: {objective}\n\nCreate the implementation plan."

        try:
            async with get_inference_client() as client:
                response = await client.chat_completion(
                    messages=[
                        {"role": "system", "content": system_prompt},
                        {"role": "user", "content": user_prompt}
                    ],
                    response_format={"type": "json_object"}, # Force JSON mode (SOTA feature)
                    temperature=0.2 # Low temp for deterministic planning
                )
                
                if isinstance(response, CompletionResult):
                    # Robust Parsing
                    try:
                        data = orjson.loads(response.content)
                        self._build_graph_from_json(data)
                        return Ok(self.graph)
                    except orjson.JSONDecodeError as e:
                        logger.error(f"Failed to parse Planner JSON: {response.content}")
                        return Err(e)
                else:
                    return Err(ValueError("Streaming not supported for planning"))
                    
        except Exception as e:
            return Err(e)

    def _build_graph_from_json(self, data: Dict[str, Any]):
        """
        Constructs graph with cycle detection check (implicit in DAG add).
        """
        tasks = data.get("tasks", [])
        if not tasks:
            raise ValueError("No tasks generated by planner")
            
        # Verify IDs exist before adding dependencies
        task_ids = {t["id"] for t in tasks}
        
        for task in tasks:
            # Validate dependencies exist
            deps = task.get("dependencies", [])
            valid_deps = [d for d in deps if d in task_ids]
            
            if len(valid_deps) != len(deps):
                logger.warning(f"Task {task['id']} has invalid dependencies Pruned.")
            
            self.graph.add_task(
                task_id=task['id'],
                description=task['description'],
                dependencies=valid_deps
            )
